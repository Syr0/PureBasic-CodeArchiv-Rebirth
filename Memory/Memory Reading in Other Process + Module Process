;Es braucht die Funktion CreateToolhelp32Snapshot() aus der kernler32.dll
Global kernel32=OpenLibrary(#PB_Any, "kernel32.dll")

;Prozdur liefert den Basepointer (Trampolin) des Moduls. 
;Die ProcessID muss via GetWindowThreadProcessId_ vorher gefunden werden.
;Modulname ist einfach die dll (z.b. "mono.dll")
;Module sind nur nötig wenn die pointer aus der exe rausgehen
Procedure.i GetModule(ProcessId.l, ModuleName.s)
  ;Handle für externen Prozess 
  Protected snapShot.i
  ;Struktur für die Eigenschaften eines Moduls
  Protected Me32.MODULEENTRY32
   ;Wenn die Library "kernel32.dll" geladen wurden
   If kernel32
     ;Rufe die Funktion ToolHelp mit der ProcessID auf. Gibt den Handle auf die Module der ProcessID
     snapShot=CallFunction(kernel32, "CreateToolhelp32Snapshot", #TH32CS_SNAPMODULE, ProcessId)
     ;falls erfolgreich
     If snapShot
       ;Bereite eine Struktur des Typs Moduleentry32 vor um die einzelnen Module nacheinander da reinzuschreiben
       ;Die Größe der Struktur wird in der Struktur festgehalten (Windows-eigen)
       Me32\dwSize=SizeOf(MODULEENTRY32)
       ;Belade die Struktur mit dem ersten Modul des Prozesses
       If CallFunction(kernel32, "Module32First", snapShot, @Me32)
         ;Werte den Modulnamen aus
         Repeat
           ;Lese String aus dem Speicherbereich Me32\szModule bis zur Nullterminierung (-1) aks ASCCI
           Protected moduleName$=PeekS(@Me32\szModule, -1, #PB_Ascii)
           ;Ist der String der gesuchten Modulnamen?
           If moduleName$=ModuleName
             ;Falls ja, abbruch und Baseaddresse aus der Struktur auslesen und returnen
             ProcedureReturn Me32\modBaseAddr
           EndIf
            ;Sonst: Nächstes Modul bis es kein Nächstes mehr gibt.
         Until Not CallFunction(kernel32, "Module32Next", snapShot, @Me32)
       EndIf
       ;Alle Module wurden durchsucht / es wurde das richtige gefunden. Jetzt den Funktionshandle freigaben (max 4048 pro Programm)
       CloseHandle_(snapShot)
     EndIf
   EndIf
   ;Wenn oben keine Baseadresse ermittelt werden konnte, gebe Null zurück
   ProcedureReturn 0
EndProcedure

;Besorge den Handle der Execuatable aus dem Speicher
Window = FindWindow_(0,"Fishing Planet")
;Wenn der Handle gefunden wurde
If Window <> #Null
  ;Besorge die dazugehörige ProcessID
  GetWindowThreadProcessId_(Window, @ProcessID)
  ;Besorge einen Handle(hProcess) mit Lese/Schreibzugriff auf diese ProcessID
  hProcess = OpenProcess_(#PROCESS_ALL_ACCESS, 0, ProcessID)
  ;Wenn nötig gehe die Module dieser ProcessID nach einen speziellen Modul durch und ermittle die Startadresse dafür
  *moduleAddress=GetModule(ProcessId, "UnityPlayer.dll")
  ;Erstelle eine 8-Byte-Variable für Pointer. Die Pointer liegen im Speicher als little-endian vor (Intel).
  ergebnis.q
  ;Lese mit dem Lese/Schreib-Handle von der Moduladresse + Offset und schreibe in die Adresse von Ergebnis alle 8 Byte.
  ;Die Erfolgsmeldung wird nicht verarbeitet. Die Anzahl der gelesenen Bytes wird ignoriert.
  ReadProcessMemory_(hProcess, *moduleAddress+$0147DED0 , @ergebnis, 8, #IGNORE)
  ;Der Ermittelte Pointer wird nun um ein neuen Offsete erhöht und selbst wieder als Zieladresse verwendet.
  ReadProcessMemory_(hProcess, ergebnis+$8    , @ergebnis, 8, #IGNORE)
  ReadProcessMemory_(hProcess, ergebnis+$8    , @ergebnis, 8, #IGNORE)
  ReadProcessMemory_(hProcess, ergebnis+$D0   , @ergebnis, 8, #IGNORE)
  ReadProcessMemory_(hProcess, ergebnis+$1D8  , @ergebnis, 8, #IGNORE)
  ReadProcessMemory_(hProcess, ergebnis+$90   , @ergebnis, 8, #IGNORE)
  ReadProcessMemory_(hProcess, ergebnis+$3C   , @ergebnis, 8, #IGNORE)
  ;Solange bis laut CheatEngine das Ergebnis erreicht wurde
  ;Je nach Ergebnis müssen mehrere Bytes(vorsicht: little endian) aus dem Speicher gelesen werden
  ;Laut CheatEngine ist das Ergebnis ein 4-Byte Wert. Bei Purebasicx64 sind Integer aber 8 Bytes lang.
  ;Daher wird das ergebnis als long, also mit 4 byte gelesen
  Schnur = PeekL(@ergebnis)
  Debug schnur
EndIf
;Unnötig aber sauber: zum Schluss wird auch der Handle auf die kernel32.dll wieder freigegeben
CloseLibrary(kernel32)
